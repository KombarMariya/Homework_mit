#include <iostream>
#include <vector>
using namespace std;

struct stack {
	int inf; 
	stack* next;
};

void push(stack*& h, int x) { // функция добавления нового элемента в стек
	stack* r = new stack; // новый элемент
	r->inf = x; //  поле inf = x
	r->next = h; // следующим элементом является h
	h = r; // теперь r является головой
}

int pop(stack*& h) { // функция удаления элемента из стека
	int i = h->inf; // значение первого элемента
	stack* p = h; // указатель на голову стека
	h = h->next; // переносим указатель на следующий элемент
	delete p; // удаляем первый элемент
	return i; // возвращаем значение
}

struct queue { // очередь
	int inf;
	queue* next; 
};

void push(queue*& h, queue*& t, int x) { // функция вставки элемента в начало очереди
	queue* r = new queue; // создаем новый элемент
	r->inf = x;
	r->next = NULL; 
	if (!h && !t) { // если очередь пуста
		h = t = r; // это голова и хвост
	}
	else {
		t->next = r; // r-следующий для хвоста
		t = r; // теперь r-хвост
	}
}

int pop(queue*& h, queue*& t) { // функция удаления элемента из очереди
	queue* r = h; // создаем указатель на голову
	int i = h->inf; // сохраняем значение головы
	h = h->next; // сдвигаем указатель на следующий элемент
	if (!h) t = NULL;
	delete r; // удаляем первый элемент
	return i; 
}

void BFS(vector<vector<int>> Gr, int n) { // функция обхода в ширину
	queue* h = NULL;
	queue* t = NULL; // создаем очередь 
	int x, y; 
	bool notempt = true;
	int* a = new int[n];
	for (int i = 0; i < n; i++) a[i] = 0; // создаём массив а, регистрирующий посещение вершин
	cout << "Вершина, откуда начнем обход - ";
	cin >> x; // спрашиваем, откуда начинаем обход
	a[x] = 1; // регистрируем посещение начальной вершины
	push(h, t, x); // добавляем вершину в очередь
	cout << x;
	while (h && notempt) {
		x = pop(h, t); // достаем из очереди первый элемент
		for (int i = 0; i < Gr[x].size(); i++) { // идем по остальным вершинам, смежным с той, которую мы достали из очереди 
			if (a[Gr[x][i]] == 0) {
				y = Gr[x][i];
				a[y] = 1; // помечаем у как посещаемую вершину
				push(h, t, y); // помещаем ее в очередь
				cout << y << " "; // выводим 
			}
		}
		notempt = false;
		for (int k = 0; k < n; k++) {
			if (a[k] == 0) {
				notempt = true; // проверка на посещение вершины
				break;
			}
		}
	}
}

void DFS(vector<vector<int>> Gr, int n) { // функция обхода в глубину
	stack* h = NULL;
	int x, y;
	bool fl = false;
	bool notempt = true;
	int* a = new int[n];
	for (int i = 0; i < n; i++) a[i] = 0; // создаём массив а, регистрирующий посещение вершин
	cout << "Вершина, откуда начнем обход - ";
	cin >> x; // спрашиваем, откуда начинаем обход
	a[x] = 1; // регистрируем посещение начальной вершины
	push(h, x); // добавляем саму вершину в стек
	cout << x << " ";
	while (h && notempt) { // пока стек не пуст
		x = h->inf; // рассмотрим из стека первый элемент
		for (int i = 0; i < Gr[x].size(); i++) { 
			if (a[Gr[x][i]] == 0) { // если есть смежная и непосещенная, то переходим к рассмотрению уже этой вершины
				y = Gr[x][i];
				fl = true;
				break;
			}
		}
		if (fl == true) { // если нашли нужную вершину
			a[y] = 1; // помечаем y как посещенную вершину
			push(h, y); // помещаем ее в стек и выводим 
			cout << y;
		}
		else {
			pop(h); // иначе переходим к вершине, не смежной с предыдущей, извлекаем вершину стека
		}
		notempt = false;
		for (int k = 0; k < n; k++) {
			if (a[k] == 0) { // проверяем, остались ли непосещенные вершины
				notempt = true;
				break;
			}
		}
		fl = false; // флаг, обозначающий наличие у вершины смежных вершин
	}
}

int main() {
	setlocale(LC_ALL, "Russian");
	int n, m, x, k, y, w;
	vector <vector<int>> Gr; // создаем двумерный вектор, выступающий в роли списка смежности
	cout << "Введите количество вершин " << endl;
	cin >> n; // спрашиваем число вершин
	for (int i = 0; i < n; i++) {
		Gr.push_back(vector<int>());
		cout << "Укажите количество соседних узлов текущего узла " << i << " ";
		cin >> k;
		cout << i << " Соседние вершины: "; // указываем соседние вершины
		for (int j = 0; j < k; j++) {
			cin >> w ;
			Gr[i].push_back(w); // заполняем список смежности
		}
	}

	BFS(Gr, n); // обход в ширину
	cout << endl;
	DFS(Gr, n); // обход в глубину
}
